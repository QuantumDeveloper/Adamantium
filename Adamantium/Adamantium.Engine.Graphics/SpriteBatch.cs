using System;
using System.Collections.Generic;
using System.Runtime.InteropServices;
using System.Text;
using Adamantium.Core;
using Adamantium.Engine.Compiler.Converter.AutoGenerated;
using Adamantium.Engine.Core;
using Adamantium.Engine.Graphics.Effects;
using Adamantium.Engine.Graphics.Effects.Generated;
using Adamantium.Engine.Graphics.Fonts;
using Adamantium.Mathematics;
using AdamantiumVulkan.Core;

namespace Adamantium.Engine.Graphics
{
    public partial class SpriteBatch : DisposableObject
    {
        private const UInt32 MaxBatchSize = 1000000;
        private const UInt16 MinBatchSize = 1024;

        private GraphicsDevice graphicsDevice;

        private Buffer<SpriteBatchItem> vertexBuffer;

        private Type vertexType;

        private static readonly Vector2F[] UVCornerCoords = { Vector2F.Zero, Vector2F.UnitX, Vector2F.UnitY, Vector2F.One };
        private byte textureId;

        private readonly Int32 initialBatchSize;

        private UInt32 spriteItemsCount; // current sprite items count between begin and end calls

        private SpriteBatchItem[] spriteItems;
        private Dictionary<IntPtr, int> textureIds;
        private Dictionary<int, Texture> texturesById;

        private TextureComparer textureComparer;
        private BackToFrontComparer backToFrontComparer;
        private FrontToBackComparer frontToBackComparer;

        private SpriteSortMode spriteSortMode;

        private SamplerState assignedSamplerState;
        private RasterizerState assignedRasterizerState;
        private DepthStencilState assignedDepthStencilState;
        private BlendState assignedBlendState;

        private readonly Effect spriteBatchEffect;
        private EffectPass spriteBatchEffectPass;

        private Effect customEffect;

        private Matrix4x4F transformMatrix;
        private Matrix4x4F final;

        private Boolean beginCalled;

        private BlendState oldBlendState;
        private DepthStencilState oldDepthStencilState;
        private RasterizerState oldRasterizerState;

        private EffectParameter effectMatrixTransform;
        private EffectParameter efffectTexture;
        private EffectParameter effectSampler;
        private EffectParameter effectUVCornerCoords;

        private EffectParameter customEffectMatrixTransform;
        private EffectParameter customEffectTexture;
        private EffectParameter customEffectTextureSampler;
        private EffectParameter customTextureCornerCoords;
        private EffectParameter customEffectSpriteBuffer;

        Vector4F? nullRect;
        Vector2F vector2Zero = Vector2F.Zero;
        Vector2F baseScale = Vector2F.One;

        private Vector2F currentScreenSize;

        /// <summary>
        /// Initializes a new instance of the <see cref="SpriteBatch"/> class
        /// </summary>
        /// <param name="graphicsDevice">The graphics device</param>
        /// <param name="initialBatchSize">The batch capacity default to 4096 (minimum 4096).</param>
        public SpriteBatch(GraphicsDevice graphicsDevice, UInt32 initialBatchSize = 4096)
        {
            this.graphicsDevice = graphicsDevice;

            if (initialBatchSize > MaxBatchSize)
            {
                this.initialBatchSize = (int)MaxBatchSize;
            }
            else if (initialBatchSize < MinBatchSize)
            {
                this.initialBatchSize = MinBatchSize;
            }
            else
            {
                this.initialBatchSize = (int)initialBatchSize;
            }

            textureComparer = new TextureComparer();
            frontToBackComparer = new FrontToBackComparer();
            backToFrontComparer = new BackToFrontComparer();

            spriteItems = new SpriteBatchItem[this.initialBatchSize];

            textureIds = new Dictionary<IntPtr, int>();
            texturesById = new Dictionary<int, Texture>();

            vertexBuffer = ToDispose(Buffer.Vertex.New<SpriteBatchItem>(graphicsDevice, (uint)spriteItems.Length));
            vertexType = typeof(SpriteBatchItem);

            var effect = new SpriteEffect(graphicsDevice);
            spriteBatchEffect = effect;

            spriteBatchEffectPass = effect.SpriteBatchRenderPass;
            spriteBatchEffect.CurrentTechnique = effect.Techniques[0];
            effectSampler = effect.TextureSampler;
            efffectTexture = effect.Texture;
            effectMatrixTransform = effect.MatrixTransform;
            effectUVCornerCoords = effect.TextureCornerCoords;
        }

        private void SaveState(
            SpriteSortMode sortMode, 
            BlendState blendState, 
            SamplerState samplerState,
            DepthStencilState depthStencilState, 
            RasterizerState rasterizerState, 
            Effect effect, 
            Matrix4x4F transformationMatrix)
        {
            if (beginCalled)
            {
                throw new Exception("You need to call End() before you can call Begin() again");
            }

            var presenterDescription = graphicsDevice.Presenter.Description;
            currentScreenSize = new Vector2F(presenterDescription.Width, presenterDescription.Height);
            spriteSortMode = sortMode;
            transformMatrix = transformationMatrix;

            assignedSamplerState = samplerState ?? graphicsDevice.SamplerStates.AnisotropicRepeat;

            assignedBlendState = blendState;
            assignedDepthStencilState = depthStencilState;
            assignedRasterizerState = rasterizerState;
            customEffect = effect;

            if (customEffect != null)
            {
                customTextureCornerCoords = customEffect.Parameters["TextureCornerCoords"];
                customEffectMatrixTransform = customEffect.Parameters["MatrixTransform"];
                customEffectTextureSampler = customEffect.Parameters["TextureSampler"];
                customEffectTexture = customEffect.Parameters["Textures"];
                customEffectSpriteBuffer = customEffect.Parameters["SpriteBuffer"];
            }
            beginCalled = true;
        }

        /// <summary>
        /// Begins a sprite batch operation using deferred sort and default state objects (BlendState.AlphaBlend, SamplerState.LinearClamp, DepthStencilState.None, RasterizerState.CullClockwise).
        /// </summary>
        /// <param name="sortMode"></param>
        /// /// <param name="effect"></param>
        public void Begin(SpriteSortMode sortMode = SpriteSortMode.NoSort, Effect effect = null)
        {
            spriteSortMode = sortMode;
            SaveState(sortMode, null, null, null, null, effect, Matrix4x4F.Identity);
        }

        /// <summary>
        /// Begins a sprite batch operation using deferred sort and specified blend, sampler, depth stencil and rasterizer states with custom effect.
        /// You can pass null for any of this objects. In that case default state will be used.
        /// Passing null effect selects the default spritebatch effect.
        /// </summary>
        /// <param name="sortMode">Sprite sort mode</param>
        /// <param name="blendState">The <see cref="BlendState"/></param>
        /// <param name="samplerState">The <see cref="SamplerState"/></param>
        /// <param name="depthStencilState">The <see cref="DepthStencilState"/></param>
        /// <param name="rasterizerState">The <see cref="RasterizerState"/></param>
        /// <param name="effect">Custom <see cref="Effect"/></param>
        public void Begin(
            SpriteSortMode sortMode, 
            BlendState blendState = null, 
            SamplerState samplerState = null,
            DepthStencilState depthStencilState = null, 
            RasterizerState rasterizerState = null, 
            Effect effect = null)
        {
            SaveState(sortMode, blendState, samplerState, depthStencilState, rasterizerState, effect, Matrix4x4F.Identity);
        }

        /// <summary>
        /// Begins a sprite batch rendering using the specified sorting mode and blend state, sampler, depth stencil, rasterizer state objects, plus a custom effect and a 2D transformation matrix. Passing null for any of the state objects selects the default default state objects. Passing a null effect selects the default SpriteBatch Class shader. 
        /// </summary>
        /// <param name="sortMode">Sprite sort mode</param>
        /// <param name="blendState">The <see cref="BlendState"/></param>
        /// <param name="samplerState">The <see cref="SamplerState"/></param>
        /// <param name="depthStencilState">The <see cref="DepthStencilState"/></param>
        /// <param name="rasterizerState">The <see cref="RasterizerState"/></param>
        /// <param name="effect">Custom <see cref="Effect"/></param>
        /// <param name="transformationMatrix">Transformation matrix</param>
        public void Begin(
            SpriteSortMode sortMode, 
            BlendState blendState, 
            SamplerState samplerState,
            DepthStencilState depthStencilState, 
            RasterizerState rasterizerState, 
            Effect effect,
            Matrix4x4F transformationMatrix)
        {
            SaveState(sortMode, blendState, samplerState, depthStencilState, rasterizerState, effect, transformationMatrix);
        }

        /// <summary>
        /// Directly perform draw operation and set back all custom states
        /// </summary>
        /// <exception cref="Exception"></exception>
        public void End()
        {
            if (!beginCalled)
            {
                throw new Exception("Begin must be called before end");
            }

            if (spriteItemsCount > 0)
            {
                PrepareForFlushing();
                FlushBatch();
            }

            if (customEffect != null)
            {
                customTextureCornerCoords = null;
                customEffectTexture = null;
                customEffectTextureSampler = null;
                customEffectMatrixTransform = null;
                customEffect = null;
            }

            textureIds.Clear();
            texturesById.Clear();
            textureId = 0;

            if (assignedRasterizerState != null)
            {
                graphicsDevice.RasterizerState = oldRasterizerState;
            }
            if (assignedBlendState != null)
            {
                graphicsDevice.BlendState = oldBlendState;
            }
            if (assignedDepthStencilState != null)
            {
                graphicsDevice.DepthStencilState = oldDepthStencilState;
            }

            beginCalled = false;
        }

        /// <summary>
        /// Adds sprite to batch with certain position and color
        /// </summary>
        /// <param name="texture">The texture</param>
        /// <param name="position">Sprite position in 2D space</param>
        /// <param name="color">Color to apply to texture</param>
        public void Draw(Texture texture, Vector2F position, Color color)
        {
            var destination = new Vector4F(position.X, position.Y, 1f, 1f);
            DrawSprite(texture, ref destination, true, ref nullRect, color, 0, ref vector2Zero);
        }

        /// <summary>
        /// Adds sprite to batch with certain destination and color
        /// </summary>
        /// <param name="texture">The texture</param>
        /// <param name="destination">A rectangle that specifies (in screen coordinates) the destination for drawing the sprite. If this rectangle is not the same size as the source rectangle, the sprite will be scaled to fit.</param>
        /// <param name="color">Color to apply to texture</param>
        public void Draw(Texture texture, RectangleF destination, Color color)
        {
            Vector4F dst = RectangleToVector4(destination);
            DrawSprite(texture, ref dst, false, ref nullRect, color, 0f, ref vector2Zero);
        }

        /// <summary>
        /// Adds sprite to batch with certain position, source rectangle and color
        /// </summary>
        /// <param name="texture">The texture</param>
        /// <param name="position">Sprite position in 2D space</param>
        /// <param name="sourceRectangle">A rectangle that specifies (in texels) the source texels from a texture. Use null to draw the entire texture.</param>
        /// <param name="color">Color to apply to texture</param>
        public void Draw(Texture texture, Vector2F position, RectangleF? sourceRectangle, Color color)
        {
            var destination = new Vector4F(position.X, position.Y, 1f, 1f);
            var source = RectangleToVector4(sourceRectangle);
            DrawSprite(texture, ref destination, true, ref source, color, 0, ref vector2Zero);
        }

        /// <summary>
        /// Adds sprite to batch with certain position color and scale
        /// </summary>
        /// <param name="texture">The texture</param>
        /// <param name="position">Sprite position in 2D space</param>
        /// <param name="color">Color to apply to texture</param>
        /// <param name="scale">Scale factor</param>
        public void Draw(Texture texture, Vector2F position, Color color, Vector2F scale)
        {
            var destination = new Vector4F(position.X, position.Y, scale.X, scale.Y);
            DrawSprite(texture, ref destination, true, ref nullRect, color, 0f, ref vector2Zero);
        }

        /// <summary>
        /// Adds sprite to batch with certain destination, source and color
        /// </summary>
        /// <param name="texture">The texture</param>
        /// <param name="destination">A rectangle that specifies (in screen coordinates) the destination for drawing the sprite. If this rectangle is not the same size as the source rectangle, the sprite will be scaled to fit.</param>
        /// <param name="sourceRectangle">A rectangle that specifies (in texels) the source texels from a texture. Use null to draw the entire texture.</param>
        /// <param name="color">Color to apply to texture</param>
        public void Draw(Texture texture, RectangleF destination, RectangleF? sourceRectangle, Color color)
        {
            Vector4F dst = RectangleToVector4(destination);
            var source = RectangleToVector4(sourceRectangle);
            DrawSprite(texture, ref dst, false, ref source, color, 0f, ref vector2Zero);
        }

        /// <summary>
        /// Adds sprite to batch with certain destination, source rectangle, color, rotation, rotation origin, sprite effects and layer depth
        /// </summary>
        /// <param name="texture">The texture</param>
        /// <param name="destination">A rectangle that specifies (in screen coordinates) the destination for drawing the sprite. If this rectangle is not the same size as the source rectangle, the sprite will be scaled to fit.</param>
        /// <param name="sourceRectangle">A rectangle that specifies (in texels) the source texels from a texture. Use null to draw the entire texture.</param>
        /// <param name="color">Color to apply to texture</param>
        /// <param name="rotation">Rotation angle</param>
        /// <param name="origin">Origin for rotation</param>
        /// <param name="effects"><see cref="SpriteEffects"/> to apply to texture</param>
        /// <param name="layerDepth">Depth of the sprite</param>
        public void Draw(
            Texture texture, 
            RectangleF destination, 
            RectangleF? sourceRectangle, 
            Color color,
            Single rotation, 
            Vector2F origin, 
            SpriteEffects effects = SpriteEffects.None, 
            Single layerDepth = 0.0f)
        {
            var dst = RectangleToVector4(destination);
            var source = RectangleToVector4(sourceRectangle);
            DrawSprite(texture, ref dst, false, ref source, color, rotation, ref origin, effects, layerDepth);
        }

        /// <summary>
        /// Adds sprite to batch with certain position, source rectangle, color, rotation, rotation origin, scale, sprite effects and layer depth
        /// </summary>
        /// <param name="texture">The texture</param>
        /// <param name="position">Position of the sprite in 2D space</param>
        /// <param name="sourceRectangle">A rectangle that specifies (in texels) the source texels from a texture. Use null to draw the entire texture.</param>
        /// <param name="color">Color to apply to texture</param>
        /// <param name="rotation">Rotation angle</param>
        /// <param name="origin">Origin for rotation</param>
        /// <param name="scale">Scale factor</param>
        /// <param name="effects"><see cref="SpriteEffects"/> to apply to texture</param>
        /// <param name="layerDepth">Depth of the sprite</param>
        public void Draw(
            Texture texture,
            Vector2F position,
            RectangleF? sourceRectangle,
            Color color,
            Single rotation,
            Vector2F origin,
            Single scale,
            SpriteEffects effects = SpriteEffects.None,
            Single layerDepth = 0.0f)
        {
            var destination = new Vector4F(position.X, position.Y, scale, scale);
            Vector4F? sourceRect = null;
            if (sourceRectangle.HasValue)
            {
                sourceRect = new Vector4F(sourceRectangle.Value.X, sourceRectangle.Value.Y, sourceRectangle.Value.Width,
                    sourceRectangle.Value.Height);
            }

            DrawSprite(texture, ref destination, true, ref sourceRect, color, rotation, ref origin, effects,
                layerDepth);
        }

        /// <summary>
        /// Adds sprite to batch with certain position, source rectangle, color, rotation, rotation origin, scale, sprite effects and layer depth
        /// </summary>
        /// <param name="destination">A rectangle that specifies the size of the sprite</param>
        /// <param name="color">Color to apply to texture</param>
        /// <param name="rotation">Rotation angle</param>
        /// <param name="origin">The sprite origin; the default is (0,0) which represents the upper-left corner</param>
        /// <param name="effects"><see cref="SpriteEffects"/> to apply to texture</param>
        /// <param name="layerDepth">Depth of the sprite</param>
        public void Draw(
            RectangleF destination,
            Color color,
            Single rotation,
            Vector2F origin,
            SpriteEffects effects = SpriteEffects.None,
            Single layerDepth = 0.0f)
        {
            var dst = RectangleToVector4(destination);
            Vector4F? src = null;
            DrawSprite(null, ref dst, false, ref src, color, rotation, ref origin, effects, layerDepth);
        }

        /// <summary>
        /// Adds sprite to batch with certain position, source rectangle, color, rotation, rotation origin, scale, sprite effects and layer depth
        /// </summary>
        /// <param name="texture">The texture</param>
        /// <param name="position">Position of the sprite in 2D space</param>
        /// <param name="sourceRectangle">A rectangle that specifies (in texels) the source texels from a texture. Use null to draw the entire texture.</param>
        /// <param name="color">Color to apply to texture</param>
        /// <param name="rotation">Rotation angle</param>
        /// <param name="origin">Origin for rotation</param>
        /// <param name="scale">Scale factor</param>
        /// <param name="effects"><see cref="SpriteEffects"/> to apply to texture</param>
        /// <param name="layerDepth">Depth of the sprite</param>
        public void Draw(
            Texture texture, 
            Vector2F position, 
            RectangleF? sourceRectangle, 
            Color color,
            Single rotation, 
            Vector2F origin, 
            Vector2F scale, 
            SpriteEffects effects = SpriteEffects.None,
            Single layerDepth = 0.0f)
        {
            var destination = new Vector4F(position.X, position.Y, scale.X, scale.Y);
            Vector4F? sourceRect = null;
            if (sourceRectangle.HasValue)
            {
                sourceRect = new Vector4F(sourceRectangle.Value.X, sourceRectangle.Value.Y, sourceRectangle.Value.Width, sourceRectangle.Value.Height);
            }
            DrawSprite(texture, ref destination, true, ref sourceRect, color, rotation, ref origin, effects,
               layerDepth);
        }

        // public void DrawString(FontAtlas font, string text, Vector2F position, Color color)
        // {
        //     if (font == null)
        //     {
        //         throw new ArgumentNullException(nameof(font));
        //     }
        //     if (String.IsNullOrEmpty(text))
        //     {
        //         return;
        //     }
        //     var drawCommand = new SpriteFont.InternalDrawCommand(this, position, color, 0f, vecto2Zero, baseScale, SpriteEffects.None, 0f);
        //     font.InternalDraw(text, ref drawCommand);
        // }
        //
        // public void DrawString(FontAtlas font, StringBuilder text, Vector2F position, Color color)
        // {
        //     if (font == null)
        //     {
        //         throw new ArgumentNullException(nameof(font));
        //     }
        //     if (text.Length == 0)
        //     {
        //         return;
        //     }
        //     var drawCommand = new SpriteFont.InternalDrawCommand(this, position, color, 0f, vecto2Zero, baseScale, SpriteEffects.None, 0f);
        //     font.InternalDraw(text.ToString(), ref drawCommand);
        // }
        //
        // public void DrawString(FontAtlas font, string text, Vector2F position, Color color, float rotation, Vector2F rotationCenter, Vector2F scale, SpriteEffects effects = SpriteEffects.None, float depth = 0f)
        // {
        //     if (font == null)
        //     {
        //         throw new ArgumentNullException(nameof(font));
        //     }
        //     if (String.IsNullOrEmpty(text))
        //     {
        //         return;
        //     }
        //     var drawCommand = new SpriteFont.InternalDrawCommand(this, position, color, rotation, rotationCenter, scale, effects, depth);
        //     font.InternalDraw(text, ref drawCommand);
        // }

        private Vector4F RectangleToVector4(RectangleF rectangle)
        {
            return new Vector4F(rectangle.X, rectangle.Y, rectangle.Width, rectangle.Height);
        }

        private Vector4F? RectangleToVector4(RectangleF? rectangle)
        {
            Vector4F? vector = null;
            if (rectangle.HasValue)
            {
                vector = new Vector4F(rectangle.Value.X, rectangle.Value.Y, rectangle.Value.Width, rectangle.Value.Height);
            }
            return vector;
        }

        internal unsafe void DrawSprite(
            Texture texture, 
            ref Vector4F destination, 
            bool scaleDestination,
            ref Vector4F? sourceRectangle, 
            Color color, 
            Single rotation, 
            ref Vector2F origin,
            SpriteEffects spriteEffects = SpriteEffects.None, 
            Single layerDepth = 0.0f)
        {
            int id = -1;
            uint width;
            uint height;
            int currentIndex;
            if (texture != null)
            {
                id = 0;
                width = texture.Width;
                height = texture.Height;
                if (!textureIds.TryGetValue(texture.ManagedPointer, out currentIndex))
                {
                    textureIds.Add(texture.ManagedPointer, textureId);
                    texturesById.Add(textureId, texture);
                    currentIndex = textureId;
                    textureId++;
                }
            }
            else
            {
                currentIndex = -1;
                width = (uint)destination.Z;
                height = (uint)destination.W;
            }

            fixed (SpriteBatchItem* item = &spriteItems[spriteItemsCount])
            {
                item->Color = color;
                item->TextureInfo = new Int4((int)width, (int)height, id, currentIndex);
                item->Depth = 1.0f - layerDepth;

                if (sourceRectangle.HasValue)
                {
                    item->Source = sourceRectangle.Value;
                    width = (uint)item->Source.Z;
                    height = (uint)item->Source.W;
                }
                else
                {
                    item->Source.X = 0f;
                    item->Source.Y = 0f;
                    item->Source.Z = width;
                    item->Source.W = height;
                }

                if (scaleDestination)
                {
                    destination.Z *= width;
                    destination.W *= height;
                }
                item->Destination = destination;
                item->Origin = origin;
                item->SpriteEffects = (int)spriteEffects;
                item->Rotation = rotation;
            }

            if (spriteItemsCount < spriteItems.Length)
            {
                spriteItemsCount++;
            }

            if (spriteItemsCount != initialBatchSize) return;
            
            PrepareForFlushing();
            FlushBatch();
        }

        private void SortSprites()
        {
            IComparer<SpriteBatchItem> comparer;

            switch (spriteSortMode)
            {
                case SpriteSortMode.Texture:
                    comparer = textureComparer;
                    break;
                case SpriteSortMode.BackToFront:
                    comparer = backToFrontComparer;
                    break;
                case SpriteSortMode.FrontToBack:
                    comparer = frontToBackComparer;
                    break;
                default:
                    return;
            }

            Array.Sort(spriteItems, 0, (int)spriteItemsCount, comparer);
        }

        private void FlushBatch()
        {
            switch (spriteSortMode)
            {
                case SpriteSortMode.Texture:
                case SpriteSortMode.BackToFront:
                case SpriteSortMode.FrontToBack:
                    SortSprites();
                    break;
            }

            UpdateSpriteItemsBuffer(0, spriteItemsCount);

            Texture previousTexture = null;
            int prevIndex = spriteItems[0].TextureInfo.W;
            uint offset = 0;
            for (uint i = 0; i < spriteItemsCount; i++)
            {
                var current = spriteItems[i].TextureInfo.W;
                if (current != prevIndex && current != -1)
                {
                    texturesById.TryGetValue(prevIndex, out previousTexture);
                    if (i > offset)
                    {
                        DrawBatch(previousTexture, offset, i - offset);
                    }
                    offset = i;

                    prevIndex = current;
                }
            }
            texturesById.TryGetValue(prevIndex, out previousTexture);
            DrawBatch(previousTexture, offset, spriteItemsCount - offset);

            textureId = 0;
            textureIds.Clear();
            texturesById.Clear();

            spriteItemsCount = 0;
        }

        private unsafe void UpdateSpriteItemsBuffer(uint startIndex, uint elementCount)
        {
            var offsetInBytes = startIndex * Utilities.SizeOf<SpriteBatchItem>();
            vertexBuffer.SetData(spriteItems, startIndex, elementCount, (uint)offsetInBytes);
        }

        private void PrepareForFlushing()
        {
            Matrix4x4F ortho = Matrix4x4F.OrthoOffCenterLH(0, currentScreenSize.X, currentScreenSize.Y, 0, 0.0f, 1.0f);
            Matrix4x4F.Multiply(ref transformMatrix, ref ortho, out final);

            if (assignedBlendState != null)
            {
                oldBlendState = graphicsDevice.BlendState;
                graphicsDevice.BlendState = assignedBlendState;
            }
            if (assignedDepthStencilState != null)
            {
                oldDepthStencilState = graphicsDevice.DepthStencilState;
                graphicsDevice.DepthStencilState = assignedDepthStencilState;
            }

            if (assignedRasterizerState == null) return;
            
            oldRasterizerState = graphicsDevice.RasterizerState;
            graphicsDevice.RasterizerState = assignedRasterizerState;
        }

        private void DrawBatch(Texture texture, uint startIndex, uint elementsCount)
        {
            //UpdateSpriteItemsBuffer(startIndex, elementsCount);

            if (customEffect != null)
            {
                var pass = customEffect.CurrentTechnique.Passes["Render"];
                customEffectTexture.SetResource(texture);
                customEffectTextureSampler.SetResource(assignedSamplerState);
                customEffectMatrixTransform.SetValue(final);
                customTextureCornerCoords.SetValue(UVCornerCoords);
                customEffectSpriteBuffer.SetResource(vertexBuffer);

                pass.Apply();
                graphicsDevice.PrimitiveTopology = PrimitiveTopology.PointList;
                graphicsDevice.Draw(elementsCount, 1, startIndex);
                pass.UnApply(true);
            }
            else
            {
                effectSampler.SetResource(assignedSamplerState);
                efffectTexture.SetResource(texture);
                effectMatrixTransform.SetValue(final);
                effectUVCornerCoords.SetValue(UVCornerCoords);
                graphicsDevice.VertexType = vertexType;
                graphicsDevice.SetVertexBuffer(vertexBuffer);
                spriteBatchEffectPass.Apply();
                graphicsDevice.PrimitiveTopology = PrimitiveTopology.PointList;
                graphicsDevice.Draw( elementsCount, 1, startIndex);
                spriteBatchEffectPass.UnApply(true);
            }
        }

        class BackToFrontComparer : IComparer<SpriteBatchItem>
        {
            public int Compare(SpriteBatchItem left, SpriteBatchItem rigth)
            {
                return rigth.Depth.CompareTo(left.Depth);
            }
        }

        class FrontToBackComparer : IComparer<SpriteBatchItem>
        {
            public int Compare(SpriteBatchItem left, SpriteBatchItem rigth)
            {
                return left.Depth.CompareTo(rigth.Depth);
            }
        }

        class TextureComparer : IComparer<SpriteBatchItem>
        {
            public int Compare(SpriteBatchItem left, SpriteBatchItem right)
            {
                return left.TextureInfo.W.CompareTo(right.TextureInfo.W);
            }
        }
    }
}
