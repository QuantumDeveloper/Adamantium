using System;
using System.Collections.Generic;
using System.Threading.Tasks;
using Adamantium.Engine.Core.Models;
using Adamantium.Engine.Compiler.Converter.AutoGenerated;
using Adamantium.Engine.Compiler.Converter.Configs;
using Adamantium.Engine.Compiler.Converter.Containers;
using Adamantium.Engine.Compiler.Converter.ConversionUtils;
using Adamantium.Engine.Compiler.Converter.Parsers;


namespace Adamantium.Engine.Compiler.Converter.Converters
{
   public class ColladaConverter: ConverterBase
   {
      private ColladaConversionExecutor executor;

      public ColladaConverter(string filePath, ConversionConfig config) : base(filePath, config)
      {
         Parser = new ColladaFileParser(filePath);
      }

      private void ParseData(List<geometry> geometrys)
      {
         foreach (var geom in geometrys)
         {
            ParseData(geom);
         }
      }

      private void ParseData(List<image> images)
      {
         foreach (var image in images)
         {
            ParseData(image);
         }
      }

      private void ParseData(List<controller> controllers)
      {
         foreach (var controller in controllers)
         {
            ParseData(controller);
         }
      }

      private void ParseData(List<animation> animations)
      {
         foreach (var animation in animations)
         {
            ParseData(animation);
         }
      }

      private void ParseData(List<material> materials, List<effect> effects)
      {
         foreach (var material in materials)
         {
            ParseData(material, effects);
         }
      }

      private void ResolveMaterialsBinding(List<visual_scene> visualScenes)
      {
         //Resolve materials corresponding to geometry
         foreach (var visualScene in visualScenes)
         {
            executor.ResolveMaterialsBinding(SceneDataContainer, visualScene);
         }
      }

      private void ParseData(List<light> lights)
      {
         foreach (var light in lights)
         {
            ParseData(light);
         }
      }


      private void ParseData(List<camera> cameras)
      {
         foreach (var camera in cameras)
         {
            ParseData(camera);
         }
      }

      protected override void Convert()
      {
         ColladaDataContainer dataContainer = (ColladaDataContainer) Parser.ParseDataAsync(Config).Result;
         if (!dataContainer.IsFileValid)
         {
            IsCancelled = true;
            return;
         }

         executor = new ColladaConversionExecutor(Config, dataContainer.Axis);
         UpAxis = dataContainer.Axis;
         SceneDataContainer.Units = dataContainer.Units;

         var controllerTask = Task.Run(() => ParseData(dataContainer.Controllers));

         var imageTask = Task.Run(()=>ParseData(dataContainer.Images));

         ParseData(dataContainer.Cameras);
         ParseData(dataContainer.Lights);

         SceneDataContainer.Models = SceneDataContainer.CreateMesh(null, "", dataContainer.FileName);

         //Получаем древовидную стуктуру мешей, чтобы сохранить её при импорте
         foreach (var visualScene in dataContainer.VisualScenes)
         {
            executor.GetMeshStructure(SceneDataContainer, visualScene, dataContainer.Geometries, dataContainer.Controllers);
         }
         Task.WaitAll(imageTask, controllerTask);

         var geometryTask = Task.Run(() => ParseData(dataContainer.Geometries)).ContinueWith(task=>ResolveMaterialsBinding(dataContainer.VisualScenes));

         var materialsTask = Task.Run(() => ParseData(dataContainer.Materials, dataContainer.Effects));

         var animationTask = Task.Run(() => ParseData(dataContainer.Animations));

         Task.WaitAll(materialsTask, geometryTask, animationTask);
      }

      #region Парсинг геометрии

      //Загружаем геометрию мешей
      private void ParseData(geometry geometry)
      {
         debugMessage = "Начинаю парсинг геометрии " + geometry.id + " в файле " + FileName;
         String meshId = String.Empty;
         String meshName = FileName;
         List<RawIndicesSemanticData> rawIndicesList = executor.GetRawIndicesCollada(geometry);
         if (rawIndicesList != null)
         {
            List<IndicesContainer> indicesContainers = new List<IndicesContainer>();
            //Получаем индексы вершин
            foreach (var indices in rawIndicesList)
            {
               indicesContainers.Add(executor.DistributeIndices(indices));
            }

            //Выбираем самую полную семантику
            Dictionary<String, VertexSemantic> semanticIdMapping = new Dictionary<string, VertexSemantic>();
            for (int i = 0; i < indicesContainers.Count; i++)
            {
               var indices = rawIndicesList[i];
               foreach (var mapping in indices.SemanticIdMapping)
               {
                  if (!semanticIdMapping.ContainsKey(mapping.Key))
                  {
                     semanticIdMapping.Add(mapping.Key, mapping.Value);
                  }
               }
            }

            Mesh mesh = executor.GetRawMesh(geometry, semanticIdMapping, out meshId, out meshName);

            SceneData.Controller controller;
            if (SceneDataContainer.Controllers.TryGetValue(meshId, out controller))
            {
               mesh.SetBoneIndices(controller.BoneIndices);
               mesh.SetBoneWeights(controller.BoneWeights);
            }

            //Собираем геометрию на основании этих индексов
            executor.ConstructMesh(SceneDataContainer, indicesContainers, mesh, meshId, meshName);

            debugMessage = "Парсинг геометрии " + geometry.id + " в файле " + FileName + " завершён";
         }
      }

      #endregion


      #region Парсинг анимации и контроллеров

      private void ParseData(controller controller)
      {
         SceneData.Controller comp = executor.GetControllerData(controller, FilePath);
         lock (SceneDataContainer.Controllers)
         {
            SceneDataContainer.Controllers.Add(comp.MeshId, comp);
         }
      }

      private void ParseData(animation animation)
      {
         object[] items = animation.Items;
         if (!(items[0] is animation))
         {
            var anim = executor.GetAnimation(animation, FilePath);
            lock (SceneDataContainer.Animation)
            {
               foreach (var controller in SceneDataContainer.Controllers)
               {
                  if (animation.id.Contains(controller.Value.Name))
                  {
                     anim.ControllerId = controller.Value.Name;
                     break;
                  }
               }
               if (!SceneDataContainer.Animation.ContainsKey(anim.FullName))
               {
                  SceneDataContainer.Animation.Add(anim.FullName, anim);
               }
            }
         }
         /*
         if (items[0] is animation)
         {
            foreach (var item in items)
            {
               lock (SceneDataContainer.Animation)
               {
                  var anim = conversionHelper.GetAnimation((animation) item, data.FilePath,
                     data.Config.MatrixTransposeNeeded, data.Axis);
                  if (!SceneDataContainer.Animation.ContainsKey(anim.FullName))
                  {
                     SceneDataContainer.Animation.Add(anim.FullName, anim);
                  }
               }
            }
         }
         */
      }

      #endregion


      #region Парсинг материалов

      private void ParseData(material material, List<effect> effects)
      {
         instance_effect effectLink = material.instance_effect;
         String id = effectLink.url.Substring(1);
         foreach (effect effect in effects)
         {
            if (effect.id == id)
            {
               var materialComponent = executor.GetMaterial(effect);
               //Присваиваем ссылку на материал, а не на эффект, чтобы не терять связи 
               //между материалами в геометрии и материалом в библиотеке материалов
               materialComponent.ID = material.id;
               lock (SceneDataContainer.Materials)
               {
                  SceneDataContainer.Materials.Add(materialComponent.ID, materialComponent);
                  break;
               }
            }
         }
      }

      #endregion


      #region Парсинг света

      private void ParseData(light light)
      {
         var l = executor.GetLight(light);
         lock (SceneDataContainer.LightData)
         {
            SceneDataContainer.LightData.Add(l.ID, l);
         }
      }

      #endregion


      #region Парсинг камер

      private void ParseData(camera camera)
      {
         var cam = executor.GetCamera(camera);
         lock (SceneDataContainer.CameraData)
         {
            SceneDataContainer.CameraData.Add(cam.ID, cam);
         }
      }

      #endregion


      #region Парсинг текстур

      private void ParseData(image img)
      {
         SceneData.Image images = executor.GetImage(FilePath, img);
         SceneDataContainer.Images.Add(images.ID, images);
      }

      #endregion
   }
}
