using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Xml.Linq;
using Adamantium.Engine.Core.Models;
using Adamantium.Engine.Compiler.Converter.AutoGenerated;
using Adamantium.Engine.Compiler.Converter.Configs;
using Adamantium.Mathematics;
using LightType = Adamantium.Engine.Core.Models.LightType;
using Adamantium.Engine.Core;

namespace Adamantium.Engine.Compiler.Converter.ConversionUtils
{
    internal class ColladaConversionExecutor : ConversionExecutorBase
    {
        private String _debugMessage;
        private const String PositionSemantic = "VERTEX";
        private const String NormalSemantic = "NORMAL";
        private const String UVSemantic = "TEXCOORD";
        private const String ColorSemantic = "COLOR";

        private const String AnimationInputSemantic = "INPUT";
        private const String AnimationOutputSemantic = "OUTPUT";
        private const String AnimationInterpolationSemantic = "INTERPOLATION";

        private const String ControllerJointSemantic = "JOINT";
        private const String ControllerWeightSemantic = "WEIGHT";
        private const String ControllerInvBindMatrixSemantic = "INV_BIND_MATRIX";

        private String Separator = ":";
        private String Separator2 = "_";

        public ColladaConversionExecutor(ConversionConfig config, UpAxis upAxis) : base(config, upAxis)
        {
        }

        #region Работа с геометрией

        internal SceneData.Model ConstructMesh(SceneData container, List<IndicesContainer> indicesContainers, Mesh mesh, String meshId, String meshName)
        {
            SceneData.Model constructedMesh = container.GetModelByID(meshId);

            if (constructedMesh == null)
            {
                constructedMesh = container.CreateMesh(container.Models, meshId, meshName);
            }
            
            foreach (var indicesContainer in indicesContainers)
            {
                var finalMesh = mesh.Clone();
                //присваиваем настоящему мешу правильную топологию
                finalMesh.MeshTopology = indicesContainer.MeshTopology;
                //присваиваем настоящему мешу семантику временного
                var semantic = indicesContainer.Semantic;
                //Собираем вершины в таком порядке, в котором они должны идти
                //то есть достаём из tempMesh.Vertices координаты вершин не по порядку как они записаны в файле,
                //а в том порядке, в котором они записаны в IndicesContainer.Vertices (в таком случае наборы коодинат могут повторяться)

                finalMesh.AssemblePositions(indicesContainer.Positions);
                finalMesh.GenerateBasicIndices();

                if (semantic.HasFlag(VertexSemantic.UV0))
                {
                    finalMesh.AssembleUVs(indicesContainer.UV0, 0);
                }

                if (semantic.HasFlag(VertexSemantic.UV1))
                {
                    finalMesh.AssembleUVs(indicesContainer.UV1, 1);
                }

                if (semantic.HasFlag(VertexSemantic.UV2))
                {
                    finalMesh.AssembleUVs(indicesContainer.UV2, 2);
                }

                if (semantic.HasFlag(VertexSemantic.UV3))
                {
                    finalMesh.AssembleUVs(indicesContainer.UV3, 3);
                }

                if (semantic.HasFlag(VertexSemantic.Color))
                {
                    finalMesh.AssembleColors(indicesContainer.Colors);
                }

                if (finalMesh.Semantic.HasFlag(VertexSemantic.JointIndices) && finalMesh.Semantic.HasFlag(VertexSemantic.JointWeights))
                {
                    finalMesh.AssembleBones(indicesContainer.Positions);
                }

                constructedMesh.Meshes.Add(finalMesh);
            }
            return constructedMesh;
        }

        //Выводить в виде геометрии, а не всего меша!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! 
        //Семантика не нужна! 
        //На выходе будет ИД меша и список геометрии
        //Парсит геометрию из файла и сортирует её по вершинам, нормалям и текстурным координатам
        public SceneData.Geometry GetRawGeometryFromCollada(geometry geometry, Dictionary<String, VertexSemantic> semanticIdMapping, out String meshId, out String name)
        {
            SceneData.Geometry rawGeometry = new SceneData.Geometry();
            Vector3F tmp = new Vector3F();
            Vector2F tmpTexture = new Vector2F();
            //Получаем его ID
            meshId = geometry.id;
            name = geometry.name;
            var mesh = geometry.Item as mesh;

            if (mesh != null)
            {
                // Считываем данные из элемента mesh
                foreach (var source in mesh.source)
                {
                    var floatArray = source.Item as float_array;
                    if (floatArray != null)
                    {
                        if (semanticIdMapping.ContainsKey(source.id))
                        {
                            VertexSemantic tempSemantic = semanticIdMapping[source.id];
                            int stride = (int)source.technique_common.accessor.stride;
                            //достаём вершины
                            if (tempSemantic == VertexSemantic.Position)
                            {
                                int index = 0;
                                for (int i = 0; i < floatArray.Values.Length; i += stride)
                                {
                                    tmp.X = (float)floatArray.Values[i];
                                    tmp.Y = (float)floatArray.Values[i + 1];
                                    tmp.Z = (float)floatArray.Values[i + 2];
                                    rawGeometry.Positions.Add(new Vector3F(tmp.ToArray()));
                                    index++;
                                }
                            }
                            //достаём первый набор текстурных координат (uv - для 3DsMax, map - Blender)
                            else if (tempSemantic == VertexSemantic.UV0)
                            {
                                for (int i = 0; i < floatArray.Values.Length; i += stride)
                                {
                                    tmpTexture.X = (float)floatArray.Values[i];
                                    tmpTexture.Y = (float)floatArray.Values[i + 1];
                                    rawGeometry.UV0.Add(tmpTexture);
                                }
                            }
                            //достаём второй набор текстурных координат (uv - для 3DsMax, map - Blender)
                            else if (tempSemantic == VertexSemantic.UV1)
                            {
                                for (int i = 0; i < floatArray.Values.Length; i += stride)
                                {
                                    tmpTexture.X = (float)floatArray.Values[i];
                                    tmpTexture.Y = (float)floatArray.Values[i + 1];
                                    rawGeometry.UV1.Add(tmpTexture);
                                }
                            }

                            else if (tempSemantic == VertexSemantic.UV2)
                            {
                                for (int i = 0; i < floatArray.Values.Length; i += stride)
                                {
                                    tmpTexture.X = (float)floatArray.Values[i];
                                    tmpTexture.Y = (float)floatArray.Values[i + 1];
                                    rawGeometry.UV2.Add(tmpTexture);
                                }
                            }

                            else if (tempSemantic == VertexSemantic.UV3)
                            {
                                for (int i = 0; i < floatArray.Values.Length; i += stride)
                                {
                                    tmpTexture.X = (float)floatArray.Values[i];
                                    tmpTexture.Y = (float)floatArray.Values[i + 1];
                                    rawGeometry.UV3.Add(tmpTexture);
                                }
                            }

                            else if (tempSemantic == VertexSemantic.Color)
                            {
                                for (int i = 0; i < floatArray.Values.Length; i += stride)
                                {
                                    var color = new Vector4F(
                                       (float)floatArray.Values[i],
                                       (float)floatArray.Values[i + 1],
                                       (float)floatArray.Values[i + 2],
                                       (float)floatArray.Values[i + 3]);
                                    rawGeometry.Colors.Add(new Color(color));
                                }
                            }
                        }
                    }
                }
            }

            return rawGeometry;
        }


        public Mesh GetRawMesh(geometry geometry, Dictionary<String, VertexSemantic> semanticIdMapping, out String meshId, out String name)
        {
            Mesh rawMesh = new Mesh();
            SceneData.Geometry rawGeometry = new SceneData.Geometry();
            Vector3F tmp = new Vector3F();
            Vector2F tmpTexture = new Vector2F();
            //Получаем его ID
            meshId = geometry.id;
            name = geometry.name;
            var mesh = geometry.Item as mesh;

            if (mesh != null)
            {
                // Считываем данные из элемента mesh
                foreach (var source in mesh.source)
                {
                    var floatArray = source.Item as float_array;
                    if (floatArray != null)
                    {
                        if (semanticIdMapping.ContainsKey(source.id))
                        {
                            VertexSemantic tempSemantic = semanticIdMapping[source.id];
                            int stride = (int)source.technique_common.accessor.stride;
                            //достаём вершины
                            switch (tempSemantic)
                            {
                                case VertexSemantic.Position:
                                    for (int i = 0; i < floatArray.Values.Length; i += stride)
                                    {
                                        //for (int j = 0; j < stride; j++)
                                        {
                                            tmp.X = (float)floatArray.Values[i];
                                            tmp.Y = (float)floatArray.Values[i + 1];
                                            tmp.Z = (float)floatArray.Values[i + 2];
                                            rawGeometry.Positions.Add(new Vector3F(tmp.ToArray()));
                                        }
                                    }
                                    break;
                                case VertexSemantic.UV0:
                                case VertexSemantic.UV1:
                                case VertexSemantic.UV2:
                                case VertexSemantic.UV3:
                                    for (int i = 0; i < floatArray.Values.Length; i += stride)
                                    {
                                        //for (int j = 0; j < stride; j++)
                                        {
                                            tmpTexture.X = (float)floatArray.Values[i];
                                            tmpTexture.Y = (float)floatArray.Values[i + 1];
                                            switch (tempSemantic)
                                            {
                                                case VertexSemantic.UV0:
                                                    rawGeometry.UV0.Add(tmpTexture);
                                                    break;
                                                case VertexSemantic.UV1:
                                                    rawGeometry.UV1.Add(tmpTexture);
                                                    break;
                                                case VertexSemantic.UV2:
                                                    rawGeometry.UV2.Add(tmpTexture);
                                                    break;
                                                case VertexSemantic.UV3:
                                                    rawGeometry.UV3.Add(tmpTexture);
                                                    break;
                                            }

                                        }
                                    }
                                    break;
                                case VertexSemantic.Color:
                                    for (int i = 0; i < floatArray.Values.Length; i += stride)
                                    {
                                        //for (int j = 0; j < stride; j++)
                                        {
                                            var color = new Vector4F(
                                               (float)floatArray.Values[i],
                                               (float)floatArray.Values[i + 1],
                                               (float)floatArray.Values[i + 2],
                                               (float)floatArray.Values[i + 3]);
                                            rawGeometry.Colors.Add(new Color(color));
                                        }
                                    }
                                    break;
                            }
                        }
                    }
                }

                rawMesh.SetPoints(rawGeometry.Positions);
                rawMesh.SetUVs(0, rawGeometry.UV0);
                rawMesh.SetUVs(1, rawGeometry.UV1);
                rawMesh.SetUVs(2, rawGeometry.UV2);
                rawMesh.SetUVs(3, rawGeometry.UV3);
                rawMesh.SetColors(rawGeometry.Colors);
            }

            return rawMesh;
        }

        //Method to get indices List from Collada versions 1.4.0 and 1.4.1
        internal List<RawIndicesSemanticData> GetRawIndicesCollada(geometry geometry)
        {
            var mesh = geometry.Item as mesh;

            if (mesh != null)
            {
                var rawDataList = new List<RawIndicesSemanticData>();
                InputLocalOffset[] inputs = null;
                InputLocal[] vertexInput = null;
                String positionId = String.Empty;
                vertices vertices = null;
                //Разбор элемента vertices
                vertices = mesh.vertices;
                vertexInput = vertices.input;
                //Преобразовываем массив индексов из строки в Int32
                if (vertexInput.Length > 1)
                {
                    //logger.Warn("В геометрии " + geometry.id + "присутствует больше одного подмеша");
                }
                else
                {
                    positionId = vertexInput[0].source.Substring(1);
                }

                foreach (var meshItem in mesh.Items)
                {
                    var rawData = new RawIndicesSemanticData();

                    if (meshItem is lines)
                    {
                        var lines = meshItem as lines;
                        String materialId = lines.material;
                        inputs = lines.input;
                        rawData.MaterialId = materialId;
                        rawData.MeshTopology = PrimitiveType.LineList;
                        rawData.RawIndices = new List<int>(COLLADA.ConvertToIntArray(lines.p));
                    }
                    //from version 1.4.0
                    else if (meshItem is polygons)
                    {
                        var triangles = meshItem as polygons;
                        String materialId = triangles.material;
                        inputs = triangles.input;
                        //Преобразовываем массив индексов из строки в Int32
                        List<int> indices = new List<int>();
                        for (int i = 0; i < triangles.Items.Length; i++)
                        {
                            var strs = ((string)triangles.Items[i]).Split(' ');
                            for (int j = 0; j < strs.Length; j++)
                            {
                                indices.Add(int.Parse(strs[j]));
                            }
                        }
                        rawData.MaterialId = materialId;
                        rawData.MeshTopology = PrimitiveType.TriangleList;
                        rawData.RawIndices = indices;
                    }
                    //Version 1.4.1
                    else if (meshItem is triangles)
                    {
                        var triangles = meshItem as triangles;
                        String materialId = triangles.material;
                        inputs = triangles.input;
                        rawData.MaterialId = materialId;
                        rawData.MeshTopology = PrimitiveType.TriangleList;
                        rawData.RawIndices = new List<int>(COLLADA.ConvertToIntArray(triangles.p));
                    }
                    //Version 1.4.1
                    else if (meshItem is polylist)
                    {
                        var triangles = meshItem as polylist;
                        String materialId = triangles.material;
                        inputs = triangles.input;
                        rawData.MaterialId = materialId;
                        rawData.MeshTopology = PrimitiveType.TriangleList;
                        rawData.RawIndices = new List<int>(COLLADA.ConvertToIntArray(triangles.p));
                        rawData.VertexType = new List<int>(COLLADA.ConvertToIntArray(triangles.vcount));
                    }
                    else
                    {
                        throw new TopologyNotSupportedException(meshItem.GetType().FullName + "is not supported");
                    }

                    //same for all versions
                    if (inputs != null)
                    {
                        foreach (var input in inputs)
                        {
                            if (input.semantic == PositionSemantic)
                            {
                                rawData.Offset.Position = input.offset;
                                if (vertices.id == input.source.Substring(1))
                                {
                                    rawData.SemanticIdMapping.Add(positionId, VertexSemantic.Position);
                                }
                                rawData.Semantic |= VertexSemantic.Position;
                            }
                            else if (input.semantic == NormalSemantic)
                            {
                                rawData.Offset.Normal = input.offset;
                                rawData.SemanticIdMapping.Add(input.source.Substring(1), VertexSemantic.Normal);
                            }
                            else if (input.semantic == UVSemantic)
                            {
                                if (input.set == 0)
                                {
                                    rawData.Offset.UV0 = input.offset;
                                    rawData.SemanticIdMapping.Add(input.source.Substring(1), VertexSemantic.UV0);
                                    rawData.Semantic |= VertexSemantic.UV0;
                                }
                                else if (input.set == 1)
                                {
                                    rawData.Offset.UV1 = input.offset;
                                    rawData.SemanticIdMapping.Add(input.source.Substring(1), VertexSemantic.UV1);
                                    rawData.Semantic |= VertexSemantic.UV1;
                                }
                                else if (input.set == 2)
                                {
                                    rawData.Offset.UV2 = input.offset;
                                    rawData.SemanticIdMapping.Add(input.source.Substring(1), VertexSemantic.UV2);
                                    rawData.Semantic |= VertexSemantic.UV2;
                                }
                                else if (input.set == 3)
                                {
                                    rawData.Offset.UV3 = input.offset;
                                    rawData.SemanticIdMapping.Add(input.source.Substring(1), VertexSemantic.UV3);
                                    rawData.Semantic |= VertexSemantic.UV3;
                                }
                            }

                            else if (input.semantic == ColorSemantic)
                            {
                                rawData.Offset.Color = input.offset;
                                rawData.SemanticIdMapping.Add(input.source.Substring(1), VertexSemantic.Color);
                                rawData.Semantic |= VertexSemantic.Color;
                            }
                            _debugMessage = "Semantic " + input.semantic + " Source " + input.source +
                                            " Offset " + input.offset;
                            //logger.Info(_debugMessage);
                        }
                    }
                    rawDataList.Add(rawData);
                }

                return rawDataList;
            }
            return null;
        }

        #endregion


        #region Работа с текстурами

        public SceneData.Image GetImage(String filePath, image img)
        {
            SceneData.Image images = new SceneData.Image();
            images.ID = img.id;
            images.ImageName = Uri.UnescapeDataString(img.Item.ToString());
            //Присваиваем реальный путь к файлу текстуры
            images.FilePath = Path.Combine(Path.GetDirectoryName(filePath), images.ImageName);
            return images;
        }

        #endregion


        #region Работа с контроллерами и анимацией

        //метод вытягивает имена костей из файла, так как автосгенерированные классы этого
        //почему-то не делают
        public String[] GetStringArrayById(String id, String path)
        {
            XDocument doc = new XDocument();
            doc = XDocument.Load(path);
            XElement field = doc.Descendants().FirstOrDefault(x => (string)x.Attribute("id") == id);
            string[] names = null;
            if (field != null)
            {
                names = COLLADA.ConvertStringArray(field.Value);
            }
            return names;
        }

        //Вытягиваем из сырых данных контроллер анимации
        public SceneData.Controller GetControllerData(controller controller, String filepath)
        {
            skin skin = controller.Item as skin;
            if (skin != null)
            {
                SceneData.Controller animationController = new SceneData.Controller();
                //Получаем ID меша, которому принадлежит контроллер
                animationController.MeshId = skin.source1.Substring(1);
                animationController.ControllerId = controller.id;
                //Try to get controller
                animationController.Name = controller.name;
                Dictionary<String, ControllerSemantic> controllerMapping = new Dictionary<string, ControllerSemantic>();
                foreach (InputLocalOffset inputLocalOffset in skin.vertex_weights.input)
                {
                    if (inputLocalOffset.semantic == ControllerJointSemantic)
                    {
                        controllerMapping.Add(inputLocalOffset.source.Substring(1), ControllerSemantic.Joint);
                    }
                    else if (inputLocalOffset.semantic == ControllerWeightSemantic)
                    {
                        controllerMapping.Add(inputLocalOffset.source.Substring(1), ControllerSemantic.Weight);
                    }
                }

                foreach (var inputLocal in skin.joints.input)
                {
                    if (inputLocal.semantic == ControllerInvBindMatrixSemantic)
                    {
                        controllerMapping.Add(inputLocal.source.Substring(1), ControllerSemantic.InverseBindMatrix);
                    }
                }

                List<int> vcountList = new List<int>(COLLADA.ConvertToIntArray(skin.vertex_weights.vcount));
                int[] list = COLLADA.ConvertToIntArray(skin.vertex_weights.v);
                List<int> bonesIndices = new List<int>();
                List<int> weightIndices = new List<int>();
                string[] jointNames = null;
                List<Matrix4x4F> jointsMatrices = new List<Matrix4x4F>();
                float[] weightsValues = null;
                source[] sources = skin.source;
                var bindShape = COLLADA.ConvertToDoubleArray(skin.bind_shape_matrix);
                animationController.BindShapeMatrix = new Matrix4x4F(Array.ConvertAll(bindShape, x => (float)x));
                foreach (source source in sources)
                {
                    ControllerSemantic semantic = controllerMapping[source.id];
                    if (semantic == ControllerSemantic.Joint)
                    {
                        Name_array nameArray = source.Item as Name_array;
                        if (nameArray != null)
                        {
                            jointNames = GetStringArrayById(nameArray.id, filepath);
                        }
                    }
                    else if (semantic == ControllerSemantic.InverseBindMatrix)
                    {
                        float_array floatArray = source.Item as float_array;
                        float[] jointArray = null;
                        if (floatArray != null)
                        {
                            jointArray = COLLADA.ConvertToFloatArray(floatArray._Text_);
                        }

                        if (jointArray != null)
                        {
                            List<float> tmpJointsList = new List<float>(COLLADA.ConvertToFloatArray(floatArray._Text_));
                            for (int i = 0; i < tmpJointsList.Count; i += 16)
                            {
                                Matrix4x4F matrix = new Matrix4x4F(tmpJointsList.GetRange(i, 16).ToArray());
                                if (config.MatrixTransposeNeeded)
                                {
                                    matrix = Matrix4x4F.Transpose(matrix);
                                }
                                if (upAxis == UpAxis.Z_UP)
                                {
                                    matrix = ZupYup * matrix * ZupYup;
                                }
                                //добавляем их в массив матриц
                                jointsMatrices.Add(matrix);
                            }
                        }
                    }

                    else if (semantic == ControllerSemantic.Weight)
                    {
                        float_array array = source.Item as float_array;
                        if (array != null)
                        {
                            weightsValues = COLLADA.ConvertToFloatArray(array._Text_);
                            if (weightsValues == null)
                            {
                                return null;
                            }
                        }
                    }
                }

                for (int i = 0; i < jointNames.Length; i++)
                {
                    animationController.JointDictionary.Add(/*animationController.SkeletonId+"_"+*/jointNames[i], jointsMatrices[i]);
                }
                animationController.JointNames.AddRange(jointNames);
                animationController.JointMatrices.AddRange(jointsMatrices);

                for (int i = 0; i < list.Length; i++)
                {
                    if (i % 2 == 0)
                    {
                        bonesIndices.Add(list[i]);
                    }
                    else
                    {
                        weightIndices.Add(list[i]);
                    }
                }

                int offset = 0;
                /*
                <v> - это массив индексов костей-весов
                То есть - каждый первый элемент - это индекс в массиве костей,
                а каждый второй - индекс в массиве весов
                */
                for (int i = 0; i < vcountList.Count; i++)
                {
                    //массив vcountList <vcount> определяет количество костей, влияющих на конкретную вершину, 
                    //по которой мы в данный момент проходим
                    Vector4F indices = new Vector4F();
                    Vector4F weights = new Vector4F();
                    for (int j = 0; j < vcountList[i]; j++)
                    {
                        /*
                        * Заполняем JointWeightCollection для каждой из вершин.
                        * То есть в итоге получится коллекция коллекций костей.
                        * Первая коллеция должна быть равна количеству вершин,
                        * а вторая - уже будет зависеть от количества костей, 
                        * прикреплённых к каждой из вершин (рекомендовано ограничиваться 4 костями на вершину) 
                        */
                        if (j == 0)
                        {
                            indices.X = bonesIndices[offset];
                            weights.X = weightsValues[weightIndices[offset]];
                        }
                        else if (j == 1)
                        {
                            indices.Y = bonesIndices[offset];
                            weights.Y = weightsValues[weightIndices[offset]];
                        }
                        else if (j == 2)
                        {
                            indices.Z = bonesIndices[offset];
                            weights.Z = weightsValues[weightIndices[offset]];
                        }
                        else if (j == 3)
                        {
                            indices.W = bonesIndices[offset];
                            weights.W = weightsValues[weightIndices[offset]];
                        }
                        offset++;
                    }
                    animationController.BoneIndices.Add(indices);
                    animationController.BoneWeights.Add(weights);
                }
                return animationController;
            }
            return null;
        }

        public SceneData.FrameCollection GetAnimation(animation animation, String filepath)
        {
            object[] items = animation.Items;
            sampler sampler = (sampler)items[items.Length - 2];
            InputLocal[] inputs = sampler.input;
            Dictionary<String, AnimationSemantic> animationMapping = new Dictionary<string, AnimationSemantic>();
            foreach (InputLocal inputLocal in inputs)
            {
                if (inputLocal.semantic == AnimationInputSemantic)
                {
                    animationMapping.Add(inputLocal.source.Substring(1), AnimationSemantic.Input);
                }
                else if (inputLocal.semantic == AnimationOutputSemantic)
                {
                    animationMapping.Add(inputLocal.source.Substring(1), AnimationSemantic.Output);
                }
                else if (inputLocal.semantic == AnimationInterpolationSemantic)
                {
                    animationMapping.Add(inputLocal.source.Substring(1), AnimationSemantic.Interpolation);
                }
            }

            SceneData.FrameCollection collection = new SceneData.FrameCollection();
            channel ch = (channel)items[items.Length - 1];
            int index = ch.target.IndexOf('/');
            collection.JointId = ch.target.Substring(0, index);
            foreach (var item in items)
            {
                if (item is source)
                {
                    source source = item as source;
                    AnimationSemantic semantic;
                    animationMapping.TryGetValue(source.id, out semantic);
                    //AnimationSemantic semantic =  animationMapping[source.id];
                    if (semantic.HasFlag(AnimationSemantic.Input))
                    {
                        float_array array = source.Item as float_array;
                        if (array != null)
                        {
                            for (int i = 0; i < array.Values.Length; i++)
                            {
                                collection.Add(new SceneData.KeyFrame() { TimeStamp = array.Values[i] });
                            }
                        }
                    }
                    else if (semantic.HasFlag(AnimationSemantic.Output))
                    {
                        //Проверяем что внутри массива. Нам нужны матрицы 4х4
                        if (source.technique_common.accessor.param[0].type == "float4x4")
                        {
                            float_array array = source.Item as float_array;
                            var values = COLLADA.ConvertToFloatArray(array._Text_);
                            if (values != null)
                            {
                                List<float> tempList = new List<float>();
                                int count = 0;
                                for (int i = 0; i < values.Length; i++)
                                {
                                    tempList.Add(values[i]);
                                    if (tempList.Count == 16)
                                    {
                                        Matrix4x4F matrix = new Matrix4x4F(tempList.ToArray());
                                        if (config.MatrixTransposeNeeded)
                                        {
                                            matrix = Matrix4x4F.Transpose(matrix);
                                        }
                                        if (upAxis == UpAxis.Z_UP)
                                        {
                                            matrix = ZupYup * matrix * ZupYup;
                                        }
                                        Vector3F scale;
                                        Vector3F position;
                                        QuaternionF rotation;
                                        matrix.Decompose(out scale, out rotation, out position);
                                        collection[count].Position = position;
                                        collection[count].Scale = scale;
                                        collection[count].Rotation = rotation;
                                        tempList.Clear();
                                        count++;
                                    }
                                }
                            }
                        }
                    }
                    else if (semantic.HasFlag(AnimationSemantic.Interpolation))
                    {
                        string[] array = GetStringArrayById(source.id, filepath);
                        if (array != null)
                        {
                            for (int i = 0; i < array.Length; i++)
                            {
                                collection[i].Interpolation =
                                   ((InterpolationType)Enum.Parse(typeof(InterpolationType), array[i], true));
                            }
                        }
                    }
                }
            }
            return collection;
        }

        #endregion


        #region Работа с визуальными сценами

        //Универсальный метод. Достаёт и собирает матрицу объекта из узла визуальной сцены
        internal MatrixParams GetObjectMatrix(node node)
        {
            bool matrixTransposeNeeded = config.MatrixTransposeNeeded;
            bool singleMatrixPresent = false;
            MatrixParams parameters = MatrixParams.Default;
            Matrix4x4F result = Matrix4x4F.Identity;
            if (node.Items == null)
            {
                return parameters;
            }

            foreach (Matrix4x4F meshMatrix in node.Items.OfType<matrix>().Select(matr => new Matrix4x4F(Array.ConvertAll(matr.Values, x => (float)x))))
            {
                if (matrixTransposeNeeded)
                {
                    meshMatrix.Transpose();
                }
                result = meshMatrix;
                singleMatrixPresent = true;
                break;
            }
            if (!singleMatrixPresent)
            {
                Vector3F translation = Vector3F.Zero;
                Vector3F scale = Vector3F.One;
                float rotationX = 0;
                float rotationY = 0;
                float rotationZ = 0;

                foreach (var item in node.Items)
                {
                    if (item is TargetableFloat3)
                    {
                        TargetableFloat3 target = item as TargetableFloat3;
                        var values = COLLADA.ConvertToFloatArray(target._Text_);
                        switch (target.sid)
                        {
                            case "scale":
                                scale = new Vector3F(values);
                                break;
                            default:
                                translation = new Vector3F(values);
                                break;
                        }
                    }
                    else if (item is rotate)
                    {
                        rotate rotate = item as rotate;
                        switch (rotate.sid)
                        {
                            case "rotationX":
                            case "rotateX":
                                rotationX = MathHelper.DegreesToRadians((float)rotate.Values[rotate.Values.Length - 1]);
                                break;
                            case "rotationY":
                            case "rotateY":
                                rotationY = MathHelper.DegreesToRadians((float)rotate.Values[rotate.Values.Length - 1]);
                                break;
                            case "rotationZ":
                            case "rotateZ":
                                rotationZ = MathHelper.DegreesToRadians((float)rotate.Values[rotate.Values.Length - 1]);
                                break;
                        }
                    }
                }
                parameters.Scale = scale;
                parameters.Translation = translation;
                parameters.Rotation = QuaternionF.RotationYawPitchRoll(rotationY, rotationX, rotationZ);

                return parameters;
                //result = Matrix4x4F.Scaling(scale) * Matrix4x4F.RotationX(rotationX) * Matrix4x4F.RotationX(rotationY) * Matrix4x4F.RotationX(rotationZ) *
                //                 Matrix4x4F.Translation(translation);

            }
            if (upAxis == UpAxis.Z_UP)
            {
                result = ZupYup * result * ZupYup;
            }
            result.Decompose(out parameters.Scale, out parameters.Rotation, out parameters.Translation);
            return parameters;
        }

        //Get hierarchy from Visual scenes node
        public void GetMeshStructure(SceneData dataContainer, visual_scene visualScene, List<geometry> geometries,
           List<controller> controllers)
        {
            if (visualScene == null)
            {
                return;
            }

            Dictionary<node, SceneData.Model> nodeToMesh = new Dictionary<node, SceneData.Model>();
            foreach (var node in visualScene.node)
            {
                if (node == null)
                {
                    continue;
                }

                Dictionary<node, SceneData.Joint> nodeToJoint = new Dictionary<node, SceneData.Joint>();

                SceneData.Joint joint = null;
                SceneData.Model mesh = null;

                var queue = new Queue<node>();
                queue.Enqueue(node);
                string controllerName = string.Empty;
                while (queue.Count > 0)
                {
                    var currentNode = queue.Dequeue();
                    GetLightsAndCameraTranformation(dataContainer, currentNode);

                    mesh = GetMeshStructure(dataContainer, currentNode, nodeToMesh, geometries, controllers);

                    if (config.GetJoints)
                    {
                        joint = GetJoint(currentNode, nodeToJoint);
                        if (joint != null && joint.ParentJoint == null)
                        {
                            List<SceneData.Joint> joints;
                            if (dataContainer.Skeletons.TryGetValue(controllerName, out joints))
                            {
                                joints.Add(joint);
                            }
                        }
                    }
                    if (currentNode.node1 != null)
                    {
                        foreach (var node1 in currentNode.node1)
                        {
                            //If child node is joint and current node is NOT joint, it means that current joint contains controller name,
                            //which is corresponding to the name of controller in library_controllers
                            if (node1.type == NodeType.JOINT
                               && currentNode.type == NodeType.NODE
                               && string.IsNullOrEmpty(controllerName))
                            {
                                controllerName = currentNode.id;
                                if (!dataContainer.Skeletons.ContainsKey(controllerName))
                                {
                                    dataContainer.Skeletons.Add(controllerName, new List<SceneData.Joint>());
                                }
                            }

                            queue.Enqueue(node1);
                            if (joint != null)
                            {
                                nodeToJoint.Add(node1, joint);
                            }
                            if (mesh != null)
                            {
                                nodeToMesh.Add(node1, mesh);
                            }
                        }
                    }
                }
            }

            RemoveDeadEndMeshes(dataContainer);
        }

        private void RemoveDeadEndMeshes(SceneData model)
        {
            List<SceneData.Model> meshesToRemove = new List<SceneData.Model>();
            Stack<SceneData.Model> stack = new Stack<SceneData.Model>();
            stack.Push(model.Models);
            while (stack.Count > 0)
            {
                var current = stack.Pop();

                if (current.Dependencies.Count == 0 && String.IsNullOrEmpty(current.ID))
                {
                    meshesToRemove.Add(current);
                }

                foreach (var mesh in current.Dependencies)
                {
                    stack.Push(mesh);
                }
            }

            foreach (var mesh in meshesToRemove)
            {
                var incorrectMesh = mesh;
                while (String.IsNullOrEmpty(incorrectMesh.ID) && incorrectMesh.Parent != null)
                {
                    var temp = incorrectMesh.Parent;
                    if (temp.Meshes.Count == 0 && temp.Parent != null)
                    {
                        incorrectMesh = temp;
                    }
                    else
                    {
                        break;
                    }
                }
                model.RemoveMesh(incorrectMesh);
            }
        }

        private SceneData.Model GetMeshStructure(SceneData model, node rootNode, Dictionary<node, SceneData.Model> nodeToMesh, List<geometry> geometries, List<controller> controllers)
        {
            if (rootNode.type != NodeType.JOINT && rootNode.instance_camera == null && rootNode.instance_light == null)
            {
                var nodeName = !String.IsNullOrEmpty(rootNode.name) ? rootNode.name : rootNode.id;
                string geometryId = String.Empty;
                if (rootNode.instance_geometry != null)
                {
                    geometryId = rootNode.instance_geometry[0].url.Substring(1);
                }
                else if (rootNode.instance_controller != null)
                {
                    var controllerId = rootNode.instance_controller[0].url.Substring(1);
                    foreach (var controller in controllers)
                    {
                        if (controllerId == controller.id)
                        {
                            geometryId = ((skin)controller.Item).source1.Substring(1);
                            break;
                        }
                    }
                }

                bool meshFound = false;
                foreach (var geometry in geometries)
                {
                    if (geometry.id == geometryId)
                    {
                        meshFound = true;
                        break;
                    }
                }

                if (meshFound || rootNode.node1 != null)
                {
                    SceneData.Model parentMesh;
                    if (!nodeToMesh.TryGetValue(rootNode, out parentMesh))
                    {
                        parentMesh = model.Models;
                    }
                    var meshData = model.CreateMesh(parentMesh, geometryId, nodeName);

                    if (config.GetMeshMatrices)
                    {
                        var matrixParams = GetObjectMatrix(rootNode);
                        meshData.Scale = matrixParams.Scale;
                        meshData.Rotation = matrixParams.Rotation;
                        meshData.Position = matrixParams.Translation;
                    }
                    return meshData;
                }
            }
            return null;
        }

        public void GetLightsAndCameraTranformation(SceneData dataContainer, node rootNode)
        {
            if (rootNode.type == NodeType.JOINT)
            {
                return;
            }

            //достаём из элемента instance_light его ID
            InstanceWithExtra[] nodeIds = rootNode.instance_light;
            if (nodeIds != null && config.LightsEnabled)
            {
                //достаём id освещения
                string lightId = nodeIds[0].url.Substring(1);
                foreach (var light in dataContainer.LightData)
                {
                    if (light.Value.ID == lightId)
                    {
                        var matrix = GetObjectMatrix(rootNode);
                        light.Value.Position = matrix.Translation;
                        light.Value.Scale = matrix.Scale;
                        light.Value.Rotation = matrix.Rotation;
                        break;
                    }
                }
            }

            //достаём из элемента instance_camera его ID
            nodeIds = rootNode.instance_camera;
            if (nodeIds != null && config.CamerasEnabled)
            {
                //достаём id меша
                string cameraId = nodeIds[0].url.Substring(1);
                //Если ID совпадает с cameraId
                foreach (var camera in dataContainer.CameraData)
                {
                    if (camera.Value.ID == cameraId)
                    {
                        var matrix = GetObjectMatrix(rootNode);
                        camera.Value.Translation = matrix.Translation;
                        camera.Value.Rotation = matrix.Rotation;
                        break;
                    }
                }
            }

        }

        private SceneData.Joint GetJoint(node rootNode, Dictionary<node, SceneData.Joint> nodeToJoint)
        {
            if (rootNode.type != NodeType.JOINT)
            {
                return null;
            }

            SceneData.Joint rootJoint;
            nodeToJoint.TryGetValue(rootNode, out rootJoint);
            var joint = new SceneData.Joint
            {
                JointSid = rootNode.sid,
                JointName = rootNode.name,
                ParentJoint = rootJoint,
            };

            rootJoint?.Children.Add(joint);

            var matr = rootNode.Items[0] as matrix;
            if (matr != null)
            {
                var matrix = new Matrix4x4F(Array.ConvertAll(matr.Values, x => (float)x));
                if (config.MatrixTransposeNeeded)
                {
                    matrix = Matrix4x4F.Transpose(matrix);
                }
                if (upAxis == UpAxis.Z_UP)
                {
                    joint.LocalMatrix = ZupYup * matrix * ZupYup;
                }
                else
                {
                    joint.LocalMatrix = matrix;
                }
            }

            return joint;
        }


        //Достаём привязку материалов из визуальных сцен
        public void ResolveMaterialsBinding(SceneData sceneData, visual_scene visualScene)
        {
            if (visualScene != null)
            {
                foreach (var node in visualScene.node)
                {
                    FindMaterialsBinding(sceneData, node);
                }
            }
        }

        private void FindMaterialsBinding(SceneData sceneData, node node)
        {
            if (node != null && node.type != NodeType.JOINT)
            {
                Stack<node> stack = new Stack<node>();
                stack.Push(node);
                while (stack.Count > 0)
                {
                    var root = stack.Pop();
                    //достаём из элемента instance_geometry его ID
                    instance_geometry[] nodeId = root.instance_geometry;
                    if (nodeId != null)
                    {
                        //достаём id меша
                        string meshId = nodeId[0].url.Substring(1);
                        //Если MeshID совпадает с geometryId
                        var mesh = sceneData.GetModelByID(meshId);
                        if (mesh != null)
                        {
                            int i = 0;
                            if (nodeId[0].bind_material != null)
                            {
                                foreach (var materialInstance in nodeId[0].bind_material.technique_common)
                                {
                                    mesh.Meshes[i].MaterialID = materialInstance.target.Substring(1);
                                    i++;
                                }
                            }
                        }
                    }
                    if (root.node1 != null)
                    {
                        foreach (var node1 in root.node1)
                        {
                            stack.Push(node1);
                        }
                    }
                }
            }
        }

        #endregion


        #region Работа с материалами

        //Преобразовываем внутренний enum типа поверхности в наш тип, чтобы знать, какую именно текстуру создавать в последствии
        private TextureDimension ResolveTextureDimension(fx_surface_type_enum surfaceType)
        {
            switch (surfaceType)
            {
                case fx_surface_type_enum.Item1D:
                    return TextureDimension.Texture1D;
                case fx_surface_type_enum.Item2D:
                    return TextureDimension.Texture2D;
                case fx_surface_type_enum.Item3D:
                    return TextureDimension.Texture3D;
                case fx_surface_type_enum.CUBE:
                    return TextureDimension.Texture3D;
                case fx_surface_type_enum.DEPTH:
                    return TextureDimension.DepthBuffer;
                case fx_surface_type_enum.RECT:
                    return TextureDimension.Rectangle;
                case fx_surface_type_enum.UNTYPED:
                    return TextureDimension.None;
            }
            return TextureDimension.None;
        }

        public SceneData.Material GetMaterial(effect effect)
        {
            SceneData.Material materialData = new SceneData.Material();

            foreach (var profile in effect.Items)
            {
                if (profile.Items != null)
                {
                    foreach (var item in profile.Items)
                    {
                        if (item is common_newparam_type)
                        {
                            var param = item as common_newparam_type;
                            if (param.ItemElementName == ItemChoiceType.surface)
                            {
                                var initFrom = param.Item as fx_surface_common;
                                //materialData.TextureDimension = ResolveTextureDimension(initFrom.type);
                                foreach (fx_surface_init_from_common init in initFrom.init_from)
                                {
                                    materialData.DiffuseMap = init.Value;
                                }
                            }
                        }
                    }
                }
                if (profile.technique.Item is effectFx_profile_abstractProfile_COMMONTechniquePhong)
                {
                    var concreteItem =
                       profile.technique.Item as effectFx_profile_abstractProfile_COMMONTechniquePhong;
                    if (!concreteItem.Equals(null))
                    {
                        if (concreteItem.emission != null)
                        {
                            var color = concreteItem.emission.Item as common_color_or_texture_typeColor;
                            if (color != null)
                            {
                                materialData.Emission =
                                   new Vector4F(Array.ConvertAll(color.Values, x => (float)x));
                            }
                        }
                        if (concreteItem.ambient != null)
                        {
                            var color =
                               concreteItem.ambient.Item as common_color_or_texture_typeColor;
                            if (color != null)
                            {
                                materialData.AmbientColor =
                                   new Vector4F(Array.ConvertAll(color.Values, x => (float)x));
                            }
                        }
                        if (concreteItem.diffuse != null)
                        {
                            if (concreteItem.diffuse.Item is common_color_or_texture_typeColor)
                            {
                                var item = concreteItem.diffuse.Item as common_color_or_texture_typeColor;
                                if (item != null)
                                {
                                    materialData.DiffuseColor =
                                       new Vector4F(Array.ConvertAll(item.Values, x => (float)x));
                                }
                            }
                        }
                        if (concreteItem.specular != null)
                        {
                            var color =
                               concreteItem.specular.Item as common_color_or_texture_typeColor;
                            if (color != null)
                            {
                                materialData.SpecularColor =
                                   new Vector4F(Array.ConvertAll(color.Values, x => (float)x));
                            }
                        }
                        if (concreteItem.reflective != null)
                        {
                            var color =
                               concreteItem.reflective.Item as common_color_or_texture_typeColor;
                            if (color != null)
                            {
                                materialData.Reflective =
                                   new Vector4F(Array.ConvertAll(color.Values, x => (float)x));
                            }
                        }
                        if (concreteItem.transparent != null)
                        {
                            var color =
                               concreteItem.transparent.Item as common_color_or_texture_typeColor;
                            if (color != null)
                            {
                                materialData.Transparent =
                                   new Vector4F(Array.ConvertAll(color.Values, x => (float)x));
                            }
                        }
                        if (concreteItem.reflectivity != null)
                        {
                            var value =
                               concreteItem.reflectivity.Item as common_float_or_param_typeFloat;
                            if (value != null)
                            {
                                materialData.Reflectivity = (Single)value.Value;
                            }
                        }
                        if (concreteItem.shininess != null)
                        {
                            var value =
                               concreteItem.shininess.Item as common_float_or_param_typeFloat;
                            if (value != null)
                            {
                                materialData.Shininess = (Single)value.Value;
                            }
                        }
                        if (concreteItem.transparency != null)
                        {
                            var value =
                               concreteItem.transparency.Item as common_float_or_param_typeFloat;
                            if (value != null)
                            {
                                materialData.Transparency = (Single)value.Value;
                            }
                        }
                        if (concreteItem.index_of_refraction != null)
                        {
                            var value =
                               concreteItem.index_of_refraction.Item as common_float_or_param_typeFloat;
                            if (value != null)
                            {
                                materialData.RefractionIndex = (Single)value.Value;
                            }
                        }
                    }
                }

                else if (profile.technique.Item is effectFx_profile_abstractProfile_COMMONTechniqueBlinn)
                {
                    var concreteItem =
                       profile.technique.Item as effectFx_profile_abstractProfile_COMMONTechniqueBlinn;

                    if (!concreteItem.Equals(null))
                    {
                        if (concreteItem.emission != null)
                        {
                            var color = concreteItem.emission.Item as common_color_or_texture_typeColor;
                            if (color != null)
                            {
                                materialData.Emission =
                                   new Vector4F(Array.ConvertAll(color.Values, x => (float)x));
                            }
                        }
                        if (concreteItem.ambient != null)
                        {
                            var color =
                               concreteItem.ambient.Item as common_color_or_texture_typeColor;
                            if (color != null)
                            {
                                materialData.AmbientColor =
                                   new Vector4F(Array.ConvertAll(color.Values, x => (float)x));
                            }
                        }
                        if (concreteItem.diffuse != null)
                        {
                            if (concreteItem.diffuse.Item is common_color_or_texture_typeColor)
                            {
                                var item = concreteItem.diffuse.Item as common_color_or_texture_typeColor;
                                if (item != null)
                                {
                                    materialData.DiffuseColor =
                                       new Vector4F(Array.ConvertAll(item.Values, x => (float)x));
                                }
                            }
                        }
                        if (concreteItem.specular != null)
                        {
                            var color =
                               concreteItem.specular.Item as common_color_or_texture_typeColor;
                            if (color != null)
                            {
                                materialData.SpecularColor =
                                   new Vector4F(Array.ConvertAll(color.Values, x => (float)x));
                            }
                        }
                        if (concreteItem.reflective != null)
                        {
                            var color =
                               concreteItem.reflective.Item as common_color_or_texture_typeColor;
                            if (color != null)
                            {
                                materialData.Reflective =
                                   new Vector4F(Array.ConvertAll(color.Values, x => (float)x));
                            }
                        }
                        if (concreteItem.transparent != null)
                        {
                            var color =
                               concreteItem.transparent.Item as common_color_or_texture_typeColor;
                            if (color != null)
                            {
                                materialData.Transparent =
                                   new Vector4F(Array.ConvertAll(color.Values, x => (float)x));
                            }
                        }
                        if (concreteItem.reflectivity != null)
                        {
                            var value =
                               concreteItem.reflectivity.Item as common_float_or_param_typeFloat;
                            if (value != null)
                            {
                                materialData.Reflectivity = (Single)value.Value;
                            }
                        }
                        if (concreteItem.shininess != null)
                        {
                            var value =
                               concreteItem.shininess.Item as common_float_or_param_typeFloat;
                            if (value != null)
                            {
                                materialData.Shininess = (Single)value.Value;
                            }
                        }
                        if (concreteItem.transparency != null)
                        {
                            var value =
                               concreteItem.transparency.Item as common_float_or_param_typeFloat;
                            if (value != null)
                            {
                                materialData.Transparency = (Single)value.Value;
                            }
                        }
                        if (concreteItem.index_of_refraction != null)
                        {
                            var value =
                               concreteItem.index_of_refraction.Item as common_float_or_param_typeFloat;
                            if (value != null)
                            {
                                materialData.RefractionIndex = (Single)value.Value;
                            }
                        }
                    }
                }

                else if (profile.technique.Item is effectFx_profile_abstractProfile_COMMONTechniqueLambert)
                {
                    var concreteItem =
                       profile.technique.Item as effectFx_profile_abstractProfile_COMMONTechniqueLambert;
                    if (!concreteItem.Equals(null))
                    {
                        if (concreteItem.emission != null)
                        {
                            var color = concreteItem.emission.Item as common_color_or_texture_typeColor;
                            if (color != null)
                            {
                                materialData.Emission =
                                   new Vector4F(Array.ConvertAll(color.Values, x => (float)x));
                            }
                        }
                        if (concreteItem.ambient != null)
                        {
                            var color =
                               concreteItem.ambient.Item as common_color_or_texture_typeColor;
                            if (color != null)
                            {
                                materialData.AmbientColor =
                                   new Vector4F(Array.ConvertAll(color.Values, x => (float)x));
                            }
                        }
                        if (concreteItem.diffuse != null)
                        {
                            if (concreteItem.diffuse.Item is common_color_or_texture_typeColor)
                            {
                                var item = concreteItem.diffuse.Item as common_color_or_texture_typeColor;
                                if (item != null)
                                {
                                    materialData.DiffuseColor =
                                       new Vector4F(Array.ConvertAll(item.Values, x => (float)x));
                                }
                            }
                        }
                        if (concreteItem.reflective != null)
                        {
                            var color =
                               concreteItem.reflective.Item as common_color_or_texture_typeColor;
                            if (color != null)
                            {
                                materialData.Reflective =
                                   new Vector4F(Array.ConvertAll(color.Values, x => (float)x));
                            }
                        }
                        if (concreteItem.transparent != null)
                        {
                            var color =
                               concreteItem.transparent.Item as common_color_or_texture_typeColor;
                            if (color != null)
                            {
                                materialData.Transparent =
                                   new Vector4F(Array.ConvertAll(color.Values, x => (float)x));
                            }
                        }
                        if (concreteItem.reflectivity != null)
                        {
                            var value =
                               concreteItem.reflectivity.Item as common_float_or_param_typeFloat;
                            if (value != null)
                            {
                                materialData.Reflectivity = (Single)value.Value;
                            }
                        }
                        if (concreteItem.transparency != null)
                        {
                            var value =
                               concreteItem.transparency.Item as common_float_or_param_typeFloat;
                            if (value != null)
                            {
                                materialData.Transparency = (Single)value.Value;
                            }
                        }
                        if (concreteItem.index_of_refraction != null)
                        {
                            var value =
                               concreteItem.index_of_refraction.Item as common_float_or_param_typeFloat;
                            if (value != null)
                            {
                                materialData.RefractionIndex = (Single)value.Value;
                            }
                        }
                    }
                }

                else if (profile.technique.Item is effectFx_profile_abstractProfile_COMMONTechniqueConstant)
                {
                    var concreteItem =
                       profile.technique.Item as effectFx_profile_abstractProfile_COMMONTechniqueConstant;

                    if (!concreteItem.Equals(null))
                    {
                        if (concreteItem.emission != null)
                        {
                            var color = concreteItem.emission.Item as common_color_or_texture_typeColor;
                            if (color != null)
                            {
                                materialData.Emission =
                                   new Vector4F(Array.ConvertAll(color.Values, x => (float)x));
                            }
                        }
                        if (concreteItem.reflective != null)
                        {
                            var color =
                               concreteItem.reflective.Item as common_color_or_texture_typeColor;
                            if (color != null)
                            {
                                materialData.Reflective =
                                   new Vector4F(Array.ConvertAll(color.Values, x => (float)x));
                            }
                        }
                        if (concreteItem.transparent != null)
                        {
                            var color =
                               concreteItem.transparent.Item as common_color_or_texture_typeColor;
                            if (color != null)
                            {
                                materialData.Transparent =
                                   new Vector4F(Array.ConvertAll(color.Values, x => (float)x));
                            }
                        }
                        if (concreteItem.reflectivity != null)
                        {
                            var value =
                               concreteItem.reflectivity.Item as common_float_or_param_typeFloat;
                            if (value != null)
                            {
                                materialData.Reflectivity = (Single)value.Value;
                            }
                        }
                        if (concreteItem.transparency != null)
                        {
                            var value =
                               concreteItem.transparency.Item as common_float_or_param_typeFloat;
                            if (value != null)
                            {
                                materialData.Transparency = (Single)value.Value;
                            }
                        }
                        if (concreteItem.index_of_refraction != null)
                        {
                            var value =
                               concreteItem.index_of_refraction.Item as common_float_or_param_typeFloat;
                            if (value != null)
                            {
                                materialData.RefractionIndex = (Single)value.Value;
                            }
                        }
                    }
                }
            }
            return materialData;
        }


        #endregion


        #region Работа со светом

        public SceneData.Light GetLight(light light)
        {
            SceneData.Light lightData = new SceneData.Light();
            lightData.ID = light.id;
            if (light.technique_common.Item is lightTechnique_commonAmbient)
            {
                var lightType = light.technique_common.Item as lightTechnique_commonAmbient;
                lightData.Color = new Vector3F(Array.ConvertAll(lightType.color.Values, x => (float)x));
                lightData.LightType = LightType.Ambient;
            }
            else if (light.technique_common.Item is lightTechnique_commonDirectional)
            {
                var lightType = light.technique_common.Item as lightTechnique_commonDirectional;
                lightData.Color = new Vector3F(Array.ConvertAll(lightType.color.Values, x => (float)x));
                lightData.LightType = LightType.Directional;
            }
            else if (light.technique_common.Item is lightTechnique_commonPoint)
            {
                var lightType = light.technique_common.Item as lightTechnique_commonPoint;
                lightData.Color = new Vector3F(Array.ConvertAll(lightType.color.Values, x => (float)x));
                lightData.ConstantAttenuation = (float)lightType.constant_attenuation.Value;
                lightData.LinearAttenuation = (float)lightType.linear_attenuation.Value;
                lightData.QuadraticAttenuation = (float)lightType.quadratic_attenuation.Value;
                lightData.LightType = LightType.Point;
            }
            else if (light.technique_common.Item is lightTechnique_commonSpot)
            {
                var lightType = light.technique_common.Item as lightTechnique_commonSpot;
                lightData.Color = new Vector3F(Array.ConvertAll(lightType.color.Values, x => (float)x));
                lightData.ConstantAttenuation = (float)lightType.constant_attenuation.Value;
                lightData.LinearAttenuation = (float)lightType.linear_attenuation.Value;
                lightData.QuadraticAttenuation = (float)lightType.quadratic_attenuation.Value;
                lightData.FalloffAngle = (float)lightType.falloff_angle.Value;
                lightData.FalloffExponent = (float)lightType.falloff_exponent.Value;
                lightData.LightType = LightType.Directional;
            }
            return lightData;
        }

        #endregion


        #region Работа с камерами

        public SceneData.Camera GetCamera(camera camera)
        {
            SceneData.Camera cameraData = new SceneData.Camera();
            cameraData.ID = camera.id;
            var cameraItem = camera.optics.technique_common.Item;
            if (cameraItem is cameraOpticsTechnique_commonPerspective)
            {
                var perspective = cameraItem as cameraOpticsTechnique_commonPerspective;
                cameraData.ZNear = (Single)perspective.znear.Value;
                cameraData.ZFar = (Single)perspective.zfar.Value;
                cameraData.ProjectionType = CameraProjectionType.Pespective;
                for (int i = 0; i < perspective.Items.Length; i++)
                {
                    if (perspective.ItemsElementName[i] == ItemsChoiceType1.xfov)
                    {
                        cameraData.FovType = FovType.XFov;
                        cameraData.Fov = (float)perspective.Items[i].Value;
                    }
                    else if (perspective.ItemsElementName[i] == ItemsChoiceType1.yfov)
                    {
                        cameraData.FovType = FovType.YFov;
                        cameraData.Fov = (float)perspective.Items[i].Value;
                    }
                    else if (perspective.ItemsElementName[i] == ItemsChoiceType1.aspect_ratio)
                    {
                        cameraData.AspectRatio = (float)perspective.Items[i].Value;
                    }
                }
            }
            return cameraData;
        }

        #endregion

    }
}
